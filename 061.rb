# Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal 
# numbers are all figurate (polygonal) numbers and are generated by 
# the following formulae:

# Triangle    P3,n=n(n+1)/2   1, 3, 6, 10, 15, ...
# Square    P4,n=n2   1, 4, 9, 16, 25, ...
# Pentagonal    P5,n=n(3n−1)/2    1, 5, 12, 22, 35, ...
# Hexagonal   P6,n=n(2n−1)    1, 6, 15, 28, 45, ...
# Heptagonal    P7,n=n(5n−3)/2    1, 7, 18, 34, 55, ...
# Octagonal   P8,n=n(3n−2)    1, 8, 21, 40, 65, ...
# The ordered set of three 4-digit numbers: 8128, 2882, 8281, has 
# three interesting properties.

# The set is cyclic, in that the last two digits of each number is 
# the first two digits of the next number (including the last number
#  with the first).
# Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), 
# and pentagonal (P5,44=2882), is represented by a different number 
# in the set.
# This is the only set of 4-digit numbers with this property.
# Find the sum of the only ordered set of six cyclic 4-digit numbers 
# for which each polygonal type: triangle, square, pentagonal, hexagonal, 
#   heptagonal, and octagonal, is represented by a different number in 
#   the set.

t1 = Time.now

def triangle(n); n * (n + 1) / 2; end
def square(n); n * n; end
def pentagonal(n); n * (3 * n - 1) / 2; end
def hexagonal(n); n * (2 * n - 1); end
def heptagonal(n); n * (5 * n - 3) / 2; end
def octagonal(n); n * (3 * n - 2); end
def is_cyclic(a, b); a.to_s[-2..-1] == b.to_s[0..1]; end

polygonals = {
  3 => ->(n) { (1..1000).map { |m| triangle m }   if n < 10_000 && n >= 1_000 },
  4 => ->(n) { (1..1000).map { |m| square m }     if n < 10_000 && n >= 1_000 },
  5 => ->(n) { (1..1000).map { |m| pentagonal m } if n < 10_000 && n >= 1_000 },
  6 => ->(n) { (1..1000).map { |m| hexagonal m }  if n < 10_000 && n >= 1_000 },
  7 => ->(n) { (1..1000).map { |m| heptagonal m } if n < 10_000 && n >= 1_000 },
  8 => ->(n) { (1..1000).map { |m| octagonal m }  if n < 10_000 && n >= 1_000 }
}

polygonals.each do |k1, v1|
  polygonals.each do |k2, v2|
    next unless k2 != k1 && is_cyclic(v1, v2)
    polygonals.each do |k3, v3| 
      next unless [k1, k2].include? k3 && is_cyclic(v2, v3)
      polygonals.each do |k4, v4| 
        next unless [k1, k2, k3].include? k4 && is_cyclic(v3, v4)
        polygonals.each do |k5, v5| 
          next unless [k1, k2, k3, k4].include? k5 && is_cyclic(v4, v5)
          polygonals.each do |k6, v6| 
            next unless [k1, k2, k3, k4, k5].include? k5 && is_cyclic(v5, v6)
            if is_cyclic(v6, v1)
              puts "found #{[v1, v2, v3, v4, v5, v6].sum} in #{Time.now - t1}s"
              return
            end
          end 
        end 
      end 
    end
  end
end

